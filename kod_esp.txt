#include <SPI.h>
#include <Ethernet.h>
#include <PubSubClient.h>

// --- W5500 Ethernet Pins ---
#define ETH_CS    5
#define ETH_RST   21

// --- Sensor Pins ---
const int trigPin = 32;
const int echoPin = 33;

// --- LED Pin ---
const int ledPin = 2;

// --- Motor 1 (Left) Pins ---
const int motor1_RPWM = 25;  // Forward
const int motor1_LPWM = 26;  // Reverse
const int motor1_EN = 27;    // Enable

// --- Motor 2 (Right) Pins ---
const int motor2_RPWM = 12;  // Forward
const int motor2_LPWM = 13;  // Reverse
const int motor2_EN = 14;    // Enable

// --- Encoder Pins ---
const int encoder1_pin = 34;
const int encoder2_pin = 35;

// --- Encoder variables ---
volatile long encoder1_count = 0;
volatile long encoder2_count = 0;
long last_encoder1 = 0;
long last_encoder2 = 0;
unsigned long last_encoder_time = 0;

// --- Network Configuration ---
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ip(192, 168, 1, 50);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 255, 0);
IPAddress mqtt_server(192, 168, 1, 1);

// --- MQTT Configuration ---
const int mqtt_port = 1883;
const char* topic_distance = "sensor/distance";
const char* topic_led = "sensor/led";
const char* topic_motor_left = "motor/left";
const char* topic_motor_right = "motor/right";
const char* topic_encoder = "sensor/encoder";

EthernetClient ethClient;
PubSubClient client(ethClient);

// --- PWM Configuration ---
const int pwmFreq = 5000;
const int pwmResolution = 8;  // 8-bit: 0-255

// Encoder interrupt handlers
void IRAM_ATTR encoder1_ISR() {
  encoder1_count++;
}

void IRAM_ATTR encoder2_ISR() {
  encoder2_count++;
}

void setup() {
  Serial.begin(9600);
  delay(1000);
  
  // --- Sensor & LED pins ---
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, LOW);
  
  // --- Motor Enable pins ---
  pinMode(motor1_EN, OUTPUT);
  pinMode(motor2_EN, OUTPUT);
  digitalWrite(motor1_EN, HIGH);  // Enable motors
  digitalWrite(motor2_EN, HIGH);
  
  // --- Setup PWM for motors (ESP32 Core 3.x) ---
  ledcAttach(motor1_RPWM, pwmFreq, pwmResolution);
  ledcAttach(motor1_LPWM, pwmFreq, pwmResolution);
  ledcAttach(motor2_RPWM, pwmFreq, pwmResolution);
  ledcAttach(motor2_LPWM, pwmFreq, pwmResolution);
  
  // Stop motors initially
  ledcWrite(motor1_RPWM, 0);
  ledcWrite(motor1_LPWM, 0);
  ledcWrite(motor2_RPWM, 0);
  ledcWrite(motor2_LPWM, 0);
  
  // --- Encoder pins with interrupts ---
  pinMode(encoder1_pin, INPUT_PULLUP);
  pinMode(encoder2_pin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(encoder1_pin), encoder1_ISR, RISING);
  attachInterrupt(digitalPinToInterrupt(encoder2_pin), encoder2_ISR, RISING);
  
  // --- Initialize W5500 ---
  Serial.println("Initializing W5500...");
  pinMode(ETH_RST, OUTPUT);
  digitalWrite(ETH_RST, LOW);
  delay(100);
  digitalWrite(ETH_RST, HIGH);
  delay(100);
  
  Ethernet.init(ETH_CS);
  Ethernet.begin(mac, ip, gateway, gateway, subnet);
  
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println("W5500 not found!");
    while (true) delay(1);
  }
  
  Serial.print("IP Address: ");
  Serial.println(Ethernet.localIP());
  
  // --- Initialize MQTT ---
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(mqtt_callback);
  
  Serial.println("Setup complete!");
}

void mqtt_callback(char* topic, byte* payload, unsigned int length) {
  String message = "";
  for (unsigned int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  
  Serial.print("MQTT [");
  Serial.print(topic);
  Serial.print("]: ");
  Serial.println(message);
  
  // --- LED Control ---
  if (String(topic) == topic_led) {
    if (message == "ON") {
      digitalWrite(ledPin, HIGH);
    } else if (message == "OFF") {
      digitalWrite(ledPin, LOW);
    }
  }
  
  // --- Motor Left Control ---
  if (String(topic) == topic_motor_left) {
    int speed = message.toInt();
    setMotor1(speed);
  }
  
  // --- Motor Right Control ---
  if (String(topic) == topic_motor_right) {
    int speed = message.toInt();
    setMotor2(speed);
  }
}

void setMotor1(int speed) {
  speed = constrain(speed, -255, 255);
  if (speed > 0) {
    ledcWrite(motor1_RPWM, speed);
    ledcWrite(motor1_LPWM, 0);
  } else if (speed < 0) {
    ledcWrite(motor1_RPWM, 0);
    ledcWrite(motor1_LPWM, -speed);
  } else {
    ledcWrite(motor1_RPWM, 0);
    ledcWrite(motor1_LPWM, 0);
  }
  Serial.print("Motor1: ");
  Serial.println(speed);
}

void setMotor2(int speed) {
  speed = constrain(speed, -255, 255);
  if (speed > 0) {
    ledcWrite(motor2_RPWM, speed);
    ledcWrite(motor2_LPWM, 0);
  } else if (speed < 0) {
    ledcWrite(motor2_RPWM, 0);
    ledcWrite(motor2_LPWM, -speed);
  } else {
    ledcWrite(motor2_RPWM, 0);
    ledcWrite(motor2_LPWM, 0);
  }
  Serial.print("Motor2: ");
  Serial.println(speed);
}

void reconnect() {
  while (!client.connected()) {
    Serial.println("Connecting to MQTT...");
    if (client.connect("ESP32_Rover")) {
      Serial.println("MQTT connected!");
      client.subscribe(topic_led);
      client.subscribe(topic_motor_left);
      client.subscribe(topic_motor_right);
    } else {
      Serial.print("Failed, rc=");
      Serial.println(client.state());
      delay(2000);
    }
  }
}

void loop() {
  Ethernet.maintain();
  
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
  
  // --- Read and publish distance ---
  static unsigned long lastDistanceTime = 0;
  if (millis() - lastDistanceTime > 100) {
    lastDistanceTime = millis();
    
    digitalWrite(trigPin, LOW);
    delayMicroseconds(2);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);
    long duration = pulseIn(echoPin, HIGH, 30000);
    float distance = duration / 2000000.0 * 343;
    
    char distStr[10];
    dtostrf(distance, 4, 2, distStr);
    client.publish(topic_distance, distStr);
  }
  
  // --- Publish encoder data every 200ms ---
  if (millis() - last_encoder_time > 200) {
    long enc1 = encoder1_count;
    long enc2 = encoder2_count;
    
    long speed1 = enc1 - last_encoder1;
    long speed2 = enc2 - last_encoder2;
    
    last_encoder1 = enc1;
    last_encoder2 = enc2;
    last_encoder_time = millis();
    
    char encStr[50];
    sprintf(encStr, "%ld,%ld,%ld,%ld", enc1, enc2, speed1, speed2);
    client.publish(topic_encoder, encStr);
  }
}
